Для подсчета времени используются тики, так как это самый надежный показатель для измерения оптимизаций. Будем считывать Performance Monitors Cycle Counter (PMCC), с помощью ассемблерной вставки.

# Изучение различных способов оптимизаций на примере рендеринга Множества Мандельброта

## О проекте

Этот проект представляет собой графическое представление множества Мандельброта, с использованием графической библиотеки SFML. В целях обучения рассматриваются три версии рендеринга множества:
1) Наивное просчитывание точек
2) Развёртка циклов (Loop unrolling)
3) Использование SIMD (Single Instruction, Multiple Data) инструкций
Множество Мандельброта — это известный фрактал, славящийся своими сложными и визуально впечатляющими узорами, которые генерируются путем итерации простой математической формулы над комплексными числами, проблема заключается в том, что она рекурсивная, поэтому для каждого пикселя на экране необходимо произвести подсчёты. Также существует формула для вычисления множества в виде итеративной последовательности значений координат комплексной плоскости (x, y), её и будем использовать.

### Формула имеет вид:
<img src="ReadmeSrc/MandelbrotFormula.png" width="300">


## План работы

Множество Мандельброта определяется как набор комплексных чисел \( c \), для которых последовательность, заданная итеративной формулой. На практике для каждого пикселя изображения:
- Координаты пикселя преобразуются в реальные координаты комплексной плоскости.
- Формула итерируется до достижения максимального количества итераций или выхода за пределы установленного диапазона от центра отсчета (Мандельброт доказал, что если длина радиус вектора для точки на какой-либо итерации превышает 2, то точка гарантированно не попадет в множество).
Такая последовательность считается расходящейся, и пиксель окрашивается в зависимости от количества итераций, потребовавшихся для превышения этого порога. Пиксели, которые не расходятся в пределах максимального числа итераций, считаются частью множества и окрашиваются в черный цвет.

Векторные инструкции позволяют выполнять одну и ту же операцию над несколькими данными одновременно. В этом проекте используются инструкции SIMD (Arm Neon Intrinsics) для вычисления итераций сразу для двух точек, что сокращает общее время вычислений по сравнению с обработкой каждого пикселя по отдельности.

## Технические характеристики устройства, на котором производились измерения

## Процессор и архитектура

- **Чип**: Apple M2 Pro
- **Архитектура**: AArch64
- **Количество ядер CPU**: 10
  - 6 ядер высокой производительности (high-performance cores)
  - 4 ядра высокой эффективности (high-efficiency cores)
- **Частота процессора**:
  - Высокопроизводительные ядра: до 3,5 ГГц
  - Эффективные ядра: до 2,4 ГГц
- **Кэш-память**:
  - Высокопроизводительные ядра (GPU):
    - L1: 192 КБ (инструкции) + 128 КБ (данные) на ядро
    - L2: 32 МБ (общий для высокопроизводительных ядер)
  - Эффективные ядра (CPU):
    - L1: 128 КБ (инструкции) + 64 КБ (данные) на ядро
    - L2: 4 МБ (общий для эффективных ядер)
- **Объем памяти**: 16 ГБ RAM
- **Пропускная способность памяти**: 200 ГБ/с

**Источники**: *Технические характеристики основаны на официальных данных Apple и сторонних технических обзорах. (https://mactracker.ca/index.html)*

## Инструменты

- **Компилятор**: GCC или Clang с поддержкой инструкций SIMD.
- **Библиотеки**: Опционально, библиотеки рендеринга изображений, такие как stb_image или OpenCV.
- **Процессор**: Процессор, поддерживающий необходимые наборы инструкций SIMD (например, Intel Core i7 с AVX2).

## Ход работы над проектом

1. **Настройка контекста**: Определение размеров изображения (ширина и высота), максимального числа итераций и области комплексной плоскости для рендеринга.

2. **Рендеринг пикселей**:
   - Для каждого пикселя преобразовать его координаты на экране в координаты на комплексной плоскости. В примере ниже `window_x` и `window_y` - координаты пикселя, `real_x`, `real_y` - получившиеся координаты точки на комплексной плоскости
        ```c
            double offset_x = ((double)window_x - WINDOW_WIDTH  / 2.0) / WINDOW_WIDTH;
            double offset_y = ((double)window_y - WINDOW_HEIGHT / 2.0) / WINDOW_HEIGHT;

            double real_x = center_x + offset_x * REAL_WIDTH * scale;
            double real_y = center_y + offset_y * REAL_HEIGHT * scale;
        ```

   - Итерировать формулу до тех пор, пока |radius_v| не станет больше чем `MAX_RADIUS` (3.0) или не будет достигнуто `MAX_ITERATIONS_COUNT` (максимальное число итераций).

   - Назначить цвет пикселю на основе количества выполненных итераций.
        ```c
        if(counter >= MAX_ITERATIONS_COUNT) {
            return sf::Color::Black;
        } else {
            uint8_t r = (8 * counter) % 255;
            uint8_t g = (1 * counter) % 255;
            uint8_t b = (4 * counter) % 255;

            sf::Color color{r, g, b, 255};

            return color;
        }
        ```

3. **Рендеринг изображения**: Сгенерировать изображение, используя графическую библиотеку SFML3.

## Векторные инструкции

На самом низком уровне многие современные процессоры имеют специальное оборудование, позволяющее одной инструкции параллельно выполнять несколько операций. Этот режим известен как одиночный поток команд, множественный поток данных
(Single-Instruction, Multiple-Data, SIMD). Эти инструкции предоставляются в основном для ускорения приложений, обрабатывающих изображения, звук и видео. Некоторые компиляторы пытаются автоматически использовать параллелизм этого вида в программах на C, но все же более надежным методом является разработка программ с использованием специальных типов векторных данных, поддерживаемых компиляторами, такими как GCC.

**Источники**: *Рэндал Э.Брайант Дэвид Р. О'Халларон "Компьютерные системы. Архитектура и программирование" Третье издание*

## Intrinsic функции

Intrinsic функции — это функции, предоставляемые компилятором, которые напрямую соответствуют определенным ассемблерным инструкциям, включая операции SIMD. Эти функции позволяют разработчикам писать векторизованный код на C или C++ без необходимости напрямую использовать ассемблер. В этом проекте Arm Neon Intrinsic функции используются для реализации векторизованных вычислений множества Мандельброта.

## Обзор методов отрисовки (renderMandelbrotFunctions)

Проект включает несколько методов рендеринга множества Мандельброта:
- **Наивная версия**: Простая реализация, которая демонстрирует поочередное вычисление для каждого пикселя, в этом случае не используются никакие оптимизации.

- **Оптимизированная версия**: Данный метод приближен к наивной реализации, но использует развертку циклов с помощью массивов состоящих из `UNROLL_LEVEL` элементов.

> [!NOTE]
> Должна компилироваться только с флагом оптимизаций -O3, в противном случае компилятор не подставит векторные инструкции и программа будет работать даже медленнее наивной версии

- **Векторизованная версия**: В этом методе используются Arm Neon Intrinsic функции, позволяющие напрямую контролировать применение SIMD инструкций.

Эти методы позволяют напрямую сравнить производительность скалярного и векторизованного подходов, демонстрируя преимущества параллельных вычислений и возможности современных компиляторов.

## Вычисление времени работы

Будем производить измерения в тактах, так как данный метод имеет наибольшую точность среди прочих и позволяет избежать погрешности, вносимой изменением тактовой частоты процессора.

Так как //////////////////////////////////////////////////////////////////////////////////////////////////////////////

## Установка

Для сборки и запуска этого проекта убедитесь, что у вас есть следующее:
- Компилятор C++, поддерживающий intrinsic функции SIMD, например GCC или Clang.
- Процессор, поддерживающий необходимые инструкции SIMD (например, SSE, AVX, AVX2).
- Опционально, библиотека для рендеринга изображений, такая как OpenCV или stb_image.

**Инструкции по сборке**:
- Склонируйте репозиторий:
  ```bash
  git clone https://github.com/livlavr/MandelbrotSet.git
  ```
- Перейдите в директорию проекта и выполните сборку с помощью предоставленного Makefile или скомпилируйте исходные файлы вручную с соответствующими флагами компилятора (например, `-mavx2` для поддержки AVX2).

## Пример использования

Программу можно запустить из командной строки с аргументами для указания размера изображения, максимального числа итераций и выходного файла. Например:
```bash
./mandelbrot -w 1920 -h 1080 -i 1000 -o mandelbrot.png
```
Эта команда создаст изображение множества Мандельброта размером 1920x1080 с максимальным количеством итераций 1000 и сохранит его в файл `mandelbrot.png`.

## Заключение

Этот проект демонстрирует эффективность использования векторных инструкций для ускорения вычислительно сложных задач, таких как рендеринг множества Мандельброта. Благодаря параллелизму SIMD время рендеринга значительно сокращается, особенно для изображений высокого разрешения или большого числа итераций. Дальнейшие оптимизации, такие как многопоточность или ускорение на GPU, могут быть исследованы для достижения еще большей производительности.

## Авторы

Разработано [livlavr](https://github.com/livlavr).
